```@meta
CurrentModule = Antique
```

# Pöschl-Teller Potential

The Pöschl-Teller potential is one of the few potentials for which the quantum mechanical Schrödinger equation has an analytical solution. It has a finite number of bound states, which can be inferred easily from its potential strength parameter. It is defined for one-dimensional systems.

## Definitions

This model is described with the time-independent Schrödinger equation
```math
  \hat{H} \psi(x) = E \psi(x),
```
and the Hamiltonian
```math
  \hat{H} = - \frac{1}{2} \frac{\mathrm{d}^2}{\mathrm{d}x ^2} + V(x).
```
Parameters are specified within the following struct.

#### Parameters
```@docs; canonical=false
Antique.PoschlTeller
```

#### Potential
```@docs; canonical=false
Antique.V(::PoschlTeller, ::Any)
```

#### Number of Bound States
```@docs; canonical=false
Antique.nmax(::PoschlTeller)
```

#### Eigen Values
```@docs; canonical=false
Antique.E(::PoschlTeller)
```

#### Eigen Functions
```@docs; canonical=false
Antique.ψ(::PoschlTeller, ::Any)
```

## Usage & Examples

[Install Antique.jl](@ref Install) for the first use and run `using Antique` before each use. The energy `E()`, wavefunction `ψ()`, potential `V()` and some other functions are suppoted. In this system, the model is generated by `PoschlTeller` and a single parameter `lambda`. It is assumed to be used within rescaled, dimensionless variables.

```julia; cache = :all; results = "hidden"
using Antique
PT = PoschlTeller(lambda=6.0)
```

Parameters:

```julia; term = true
PT.lambda
```

Eigen values:

```julia; term = true
E(PT,n=0)
E(PT,n=1)
E(PT,n=2)
E(PT,n=3)
E(PT,n=4)
E(PT,n=5)
```

Wave functions:

```julia
lambda = 4.0
PT = PoschlTeller(lambda)

using Plots
plot(xlim=(-4,4), ylim=(-11.0,1.0), xlabel="\$x\$", ylabel="\$V(x),~E_n,~\\psi_n(x)+E_n\$", size=(480,400), dpi=300)
for n in 0:3
  # classical turning point:
  xE = acosh(sqrt(lambda*(lambda+1)/abs(E(PT,n=n))/2))
  # energy
  hline!([E(PT, n=n)], lc=:black, ls=:dash, label="")
  plot!([-xE,xE], fill(E(PT, n=n),2), lc=:black, lw=2, label="")
  # wave function
  plot!(x -> E(PT, n=n) + ψ(PT, x,n=n), lc=n+1, lw=2, label="\$n = $n\$")
end
# potential
plot!(x -> V(PT, x), lc=:black, lw=2, label="")
```

Potential energy curve, Energy levels, Wave functions:

```julia
lambda = 4.0
PT = PoschlTeller(lambda)

using Plots
plot(xlim=(-4,4), ylim=(-11.0,1.0), xlabel="\$x\$", ylabel="\$V(x),~E_n,~\\psi_n(x)+E_n\$", size=(480,400), dpi=300)
for n in 0:3
  # classical turning point:
  xE = acosh(sqrt(lambda*(lambda+1)/abs(E(PT,n=n))/2))
  # energy
  hline!([E(PT, n=n)], lc=:black, ls=:dash, label="")
  plot!([-xE,xE], fill(E(PT, n=n),2), lc=:black, lw=2, label="")
  # wave function
  plot!(x -> E(PT, n=n) + ψ(PT, x,n=n), lc=n+1, lw=2, label="\$n = $n\$")
end
# potential
plot!(x -> V(PT, x), lc=:black, lw=2, label="")
```

## Testing

Unit testing and Integration testing were done using numerical integration ([QuadGK.jl](https://juliamath.github.io/QuadGK.jl/stable/)). The test script is [here](https://github.com/ohno/Antique.jl/blob/main/test/PoschlTeller.jl).

```julia; line_width = 500
println(Antique.load("../../test/result/PoschlTeller.log"))
```